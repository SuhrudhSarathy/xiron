{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Getting Started with Xiron xiron is a light weight 2D Robot Simulator written entirely in the Rust Programming language . xiron was intended to be used for two purposes. Firstly, it is aimed to reduce the entry barrier to the field of Robotics by proiving an easy to use 2D simulator. Secondly, it is intended to provide a fast and light weight simulator to test and prototype navigation algorithms without the use of realistic simulations. Inspiration The inspiration to develop Xiron came from a basic need to setup up quick simulations. There were limited simulators that were independent of ROS and had a simple Python interface that fit my use case. Additionally, I wanted to learn more about the Rust Programming Langauge and ended up using it for the project. Great Alternatives Some great alternatives that provide simple 2D robot simulations 1. Flatland Simulator : Perfromant 2D simulator developed by Avidbots Corp 2. Pyrobosim : Pyrobosim is a ROS 2 enabled 2D mobile robot simulator for behavior prototyping. Overview User Guide: Configuration GUI usage Python Interface Advanced Usage Customising Robot Model Multi Robot Usage Rust Interface Contributions Feel free to contribute to the project. Take a look at the Contributor's Guide for more information.","title":"Home"},{"location":"#getting-started-with-xiron","text":"xiron is a light weight 2D Robot Simulator written entirely in the Rust Programming language . xiron was intended to be used for two purposes. Firstly, it is aimed to reduce the entry barrier to the field of Robotics by proiving an easy to use 2D simulator. Secondly, it is intended to provide a fast and light weight simulator to test and prototype navigation algorithms without the use of realistic simulations.","title":"Getting Started with Xiron"},{"location":"#inspiration","text":"The inspiration to develop Xiron came from a basic need to setup up quick simulations. There were limited simulators that were independent of ROS and had a simple Python interface that fit my use case. Additionally, I wanted to learn more about the Rust Programming Langauge and ended up using it for the project.","title":"Inspiration"},{"location":"#great-alternatives","text":"Some great alternatives that provide simple 2D robot simulations 1. Flatland Simulator : Perfromant 2D simulator developed by Avidbots Corp 2. Pyrobosim : Pyrobosim is a ROS 2 enabled 2D mobile robot simulator for behavior prototyping.","title":"Great Alternatives"},{"location":"#overview","text":"User Guide: Configuration GUI usage Python Interface Advanced Usage Customising Robot Model Multi Robot Usage Rust Interface","title":"Overview"},{"location":"#contributions","text":"Feel free to contribute to the project. Take a look at the Contributor's Guide for more information.","title":"Contributions"},{"location":"contributions/","text":"Contribute to Xiron","title":"Contributions"},{"location":"contributions/#contribute-to-xiron","text":"","title":"Contribute to Xiron"},{"location":"installation/","text":"Installation There are two modes of Installation. Since the project is not fully stable yet, it is advised to install from source. Make sure you have the Rust Programming language installed. Refer to the official website 1. Installation from crates.io Xiron can be downloaded from crates.io using cargo install xiron In a new terminal, run the simulator using xiron_simulator 2. Source Installation a. Dependencies Installation Install the Rust Programming language from their official website On Linux, you need to first run: sudo apt-get install -y libclang-dev libgtk-3-dev libxcb-render0-dev libxcb-shape0-dev libxcb-xfixes0-dev libxkbcommon-dev libssl-dev On Fedora Rawhide, you need to run dnf install clang clang-devel clang-tools-extra libxkbcommon-devel pkg-config openssl-devel libxcb-devel gtk3-devel atk fontconfig-devel There are no dependencies apart from Rust for Windows and Mac . To install from source, you will need to install the Rust Programming language. b. Source Code Clone the source code from Github git clone https://github.com/SuhrudhSarathy/xiron.git c. Build Library and Simulator To build the library and simulator run: cargo build By default, this will build the library and simulator in debug mode. To build in release mode, cargo build --release The built simulator can be found as a binary in the target/debug or target/release folder depending on whether the build was in debug mode or release mode. You can also run the simulator using cargo with cargo run --bin xiron_simulator This runs the simulator in debug mode. To run in release mode, cargo run --bin xiron_simulator --release","title":"Installation"},{"location":"installation/#installation","text":"There are two modes of Installation. Since the project is not fully stable yet, it is advised to install from source. Make sure you have the Rust Programming language installed. Refer to the official website","title":"Installation"},{"location":"installation/#1-installation-from-cratesio","text":"Xiron can be downloaded from crates.io using cargo install xiron In a new terminal, run the simulator using xiron_simulator","title":"1. Installation from crates.io"},{"location":"installation/#2-source-installation","text":"","title":"2. Source Installation"},{"location":"installation/#a-dependencies-installation","text":"Install the Rust Programming language from their official website On Linux, you need to first run: sudo apt-get install -y libclang-dev libgtk-3-dev libxcb-render0-dev libxcb-shape0-dev libxcb-xfixes0-dev libxkbcommon-dev libssl-dev On Fedora Rawhide, you need to run dnf install clang clang-devel clang-tools-extra libxkbcommon-devel pkg-config openssl-devel libxcb-devel gtk3-devel atk fontconfig-devel There are no dependencies apart from Rust for Windows and Mac . To install from source, you will need to install the Rust Programming language.","title":"a. Dependencies Installation"},{"location":"installation/#b-source-code","text":"Clone the source code from Github git clone https://github.com/SuhrudhSarathy/xiron.git","title":"b. Source Code"},{"location":"installation/#c-build-library-and-simulator","text":"To build the library and simulator run: cargo build By default, this will build the library and simulator in debug mode. To build in release mode, cargo build --release The built simulator can be found as a binary in the target/debug or target/release folder depending on whether the build was in debug mode or release mode. You can also run the simulator using cargo with cargo run --bin xiron_simulator This runs the simulator in debug mode. To run in release mode, cargo run --bin xiron_simulator --release","title":"c. Build Library and Simulator"},{"location":"advanced/multi_robot_usage/","text":"","title":"Multi Robot Usage"},{"location":"advanced/robot_model/","text":"","title":"Customising Robot Model"},{"location":"advanced/rust_interface/","text":"","title":"Rust Interface"},{"location":"user_guide/configuration/","text":"Configuring the Simulator The configuration of the Simulator's state is done through the use of YAML files. Below is an example of a sample YAML file. robots: - id: robot0 pose: - -6.295703 - 7.076855 - 0.0 vel: - 0.0 - 0.0 lidar: true footprint: - 0.25 drive_type: Differential add_noise: false - id: robot1 pose: - -4.0486326 - 4.9811525 - 0.0 vel: - 0.0 - 0.0 lidar: true footprint: - 0.25 drive_type: Differential add_noise: false walls: - endpoints: - - -9.1560545 - 8.704004 - - -1.0940428 - 8.6789055 - - -0.99091816 - 3.9499025 - - -9.038574 - 4.1187496 - endpoints: - - 1.0652351 - 8.664355 - - 1.0892582 - 4.006152 - - 9.079687 - 4.0520506 static_objects: - center: - 2.2917004 - 6.981738 width: 0.625 height: 0.625 rotation: 0.0 - center: - 7.0378914 - 6.6941404 width: 0.625 height: 0.625 rotation: 0.0 - center: - 0.020019531 - 2.6319332 width: 0.625 height: 0.625 rotation: 0.0 Three categories of objects There are three main categories of Objects used in the Simulator, Robot , Static Object , Wall . The configuration for each of these is described differently. In general, the YAML can be split as a combination of these categories as below robots: - ... - ... - ... walls: - ... - ... - ... static_objects: - ... - ... - ... Configuring a Robot Property Description Data Type id Describes the id of the Robot. string pose Describes the pose of the Robot. This is a tuple of [ x , y , yaw ]. Tuple of [ x , y , yaw ] vel Describes the velocity of the Robot. Varies according to drive type: Differential drive: [vx, vy] Omnidirectional drive: velocity in x and y direction Ackermann drive: linear velocity and steering angle. Varies according to drive type: Differential drive: [vx, vy] Omnidirectional drive: velocity in x and y direction Ackermann drive: linear velocity and steering angle. lidar Describes the presence of a lidar. bool footprint Describes the footprint. If float , the shape of the robot is circular with the given number as radius. If a tuple of float , the first number is taken as width and the second number as height. float or Tuple of float drive_type Describes the drive type. Can be Differential , OmniDirectional , or Ackermann . string add_noise Adds noise to the kinematics model. bool An example YAML configuration with Ackermann drive and Rectangular Footprint is given below - id: robot1 pose: - -4.825901 - 8.391234 - 0.35 vel: - 1.5 - 0.0 lidar: true footprint: - 0.4 - 1.2 drive_type: Ackermann add_noise: true Configuring a Static Object Here's a table generated from the YAML data: Property Description Data Type static_objects List of static objects List of objects center Center coordinates of the object Tuple of [ x , y ] width Width of the object float height Height of the object float rotation Rotation of the object float In this table, I've represented the YAML data as a table with property names, descriptions, and data types for each field. Configuring a Wall Property Description Data Type endpoints List of endpoint coordinates List of Tuples of XY coordinates of vertices Note It is highly recommended to create a starting configuration using the GUI and edit the specifics from the YAML file.","title":"Configuration"},{"location":"user_guide/configuration/#configuring-the-simulator","text":"The configuration of the Simulator's state is done through the use of YAML files. Below is an example of a sample YAML file. robots: - id: robot0 pose: - -6.295703 - 7.076855 - 0.0 vel: - 0.0 - 0.0 lidar: true footprint: - 0.25 drive_type: Differential add_noise: false - id: robot1 pose: - -4.0486326 - 4.9811525 - 0.0 vel: - 0.0 - 0.0 lidar: true footprint: - 0.25 drive_type: Differential add_noise: false walls: - endpoints: - - -9.1560545 - 8.704004 - - -1.0940428 - 8.6789055 - - -0.99091816 - 3.9499025 - - -9.038574 - 4.1187496 - endpoints: - - 1.0652351 - 8.664355 - - 1.0892582 - 4.006152 - - 9.079687 - 4.0520506 static_objects: - center: - 2.2917004 - 6.981738 width: 0.625 height: 0.625 rotation: 0.0 - center: - 7.0378914 - 6.6941404 width: 0.625 height: 0.625 rotation: 0.0 - center: - 0.020019531 - 2.6319332 width: 0.625 height: 0.625 rotation: 0.0","title":"Configuring the Simulator"},{"location":"user_guide/configuration/#three-categories-of-objects","text":"There are three main categories of Objects used in the Simulator, Robot , Static Object , Wall . The configuration for each of these is described differently. In general, the YAML can be split as a combination of these categories as below robots: - ... - ... - ... walls: - ... - ... - ... static_objects: - ... - ... - ...","title":"Three categories of objects"},{"location":"user_guide/configuration/#configuring-a-robot","text":"Property Description Data Type id Describes the id of the Robot. string pose Describes the pose of the Robot. This is a tuple of [ x , y , yaw ]. Tuple of [ x , y , yaw ] vel Describes the velocity of the Robot. Varies according to drive type: Differential drive: [vx, vy] Omnidirectional drive: velocity in x and y direction Ackermann drive: linear velocity and steering angle. Varies according to drive type: Differential drive: [vx, vy] Omnidirectional drive: velocity in x and y direction Ackermann drive: linear velocity and steering angle. lidar Describes the presence of a lidar. bool footprint Describes the footprint. If float , the shape of the robot is circular with the given number as radius. If a tuple of float , the first number is taken as width and the second number as height. float or Tuple of float drive_type Describes the drive type. Can be Differential , OmniDirectional , or Ackermann . string add_noise Adds noise to the kinematics model. bool An example YAML configuration with Ackermann drive and Rectangular Footprint is given below - id: robot1 pose: - -4.825901 - 8.391234 - 0.35 vel: - 1.5 - 0.0 lidar: true footprint: - 0.4 - 1.2 drive_type: Ackermann add_noise: true","title":"Configuring a Robot"},{"location":"user_guide/configuration/#configuring-a-static-object","text":"Here's a table generated from the YAML data: Property Description Data Type static_objects List of static objects List of objects center Center coordinates of the object Tuple of [ x , y ] width Width of the object float height Height of the object float rotation Rotation of the object float In this table, I've represented the YAML data as a table with property names, descriptions, and data types for each field.","title":"Configuring a Static Object"},{"location":"user_guide/configuration/#configuring-a-wall","text":"Property Description Data Type endpoints List of endpoint coordinates List of Tuples of XY coordinates of vertices","title":"Configuring a Wall"},{"location":"user_guide/configuration/#note","text":"It is highly recommended to create a starting configuration using the GUI and edit the specifics from the YAML file.","title":"Note"},{"location":"user_guide/gui_usage/","text":"GUI Usage Check out the below video for a detailed How to use Guide for the GUI.","title":"GUI usage"},{"location":"user_guide/gui_usage/#gui-usage","text":"Check out the below video for a detailed How to use Guide for the GUI.","title":"GUI Usage"},{"location":"user_guide/python_interface/","text":"Python Interface To interact with the simulation and send control commands to the robot(s), the Python Interface xiron_py can be used. Dependencies Make sure you have python installed on your system. Python can be installed from here Install pip to manage dependencies. Instructions are available here Installation Use pip to install the module. To install it directly from github: pip install git+https://github.com/SuhrudhSarathy/xironpy.git To install from source, clone the repository and use pip to install git clone https://github.com/SuhrudhSarathy/xironpy.git cd xironpy pip install -e . Usage A simple example demonstating the use of callback function to gather scan and pose data and use velocity publisher to send control commands is shown below. from xiron_py.comms import XironContext from xiron_py.data import Twist from time import sleep def scan_callback(msg): print(f\"Recieved Scan message: {msg}\") def pose_callback(msg): print(f\"Recieved Pose message: {msg}\") if __name__ == \"__main__\": # Create a context object ctx = XironContext() # Create the Velocity publisher for robot0 vel_pub = ctx.create_vel_publisher(\"robot0\") # Create the Scan Subscriber and add callback function ctx.create_scan_subscriber(\"robot0\", scan_callback) # Create the Pose Subscriber and add callback function ctx.create_pose_subscriber(\"robot0\", pose_callback) twist_message = Twist(\"robot0\", [0.1, 0.0], 0.1) for i in range(100): vel_pub.publish(twist_message) print(\"Publihsed vel: \", i) sleep(0.1) twist_message = Twist(\"robot0\", [0.0, 0.0], 0.0) vel_pub.publish(twist_message) print(\"Done!\") Datatypes Information about Pose , LaserScan data and Twist (velocity) of the robot are passed via the python dataclasses below. @dataclass class Twist: robot_id: str linear: tuple[float, float] angular: float @dataclass class Pose: robot_id: str position: tuple[float, float] orientation: float @dataclass class LaserScan: robot_id: str angle_min: float angle_max: float num_readings: int values: List[float] The source code for xiron_py is hosted here .","title":"Python Interface"},{"location":"user_guide/python_interface/#python-interface","text":"To interact with the simulation and send control commands to the robot(s), the Python Interface xiron_py can be used.","title":"Python Interface"},{"location":"user_guide/python_interface/#dependencies","text":"Make sure you have python installed on your system. Python can be installed from here Install pip to manage dependencies. Instructions are available here","title":"Dependencies"},{"location":"user_guide/python_interface/#installation","text":"Use pip to install the module. To install it directly from github: pip install git+https://github.com/SuhrudhSarathy/xironpy.git To install from source, clone the repository and use pip to install git clone https://github.com/SuhrudhSarathy/xironpy.git cd xironpy pip install -e .","title":"Installation"},{"location":"user_guide/python_interface/#usage","text":"A simple example demonstating the use of callback function to gather scan and pose data and use velocity publisher to send control commands is shown below. from xiron_py.comms import XironContext from xiron_py.data import Twist from time import sleep def scan_callback(msg): print(f\"Recieved Scan message: {msg}\") def pose_callback(msg): print(f\"Recieved Pose message: {msg}\") if __name__ == \"__main__\": # Create a context object ctx = XironContext() # Create the Velocity publisher for robot0 vel_pub = ctx.create_vel_publisher(\"robot0\") # Create the Scan Subscriber and add callback function ctx.create_scan_subscriber(\"robot0\", scan_callback) # Create the Pose Subscriber and add callback function ctx.create_pose_subscriber(\"robot0\", pose_callback) twist_message = Twist(\"robot0\", [0.1, 0.0], 0.1) for i in range(100): vel_pub.publish(twist_message) print(\"Publihsed vel: \", i) sleep(0.1) twist_message = Twist(\"robot0\", [0.0, 0.0], 0.0) vel_pub.publish(twist_message) print(\"Done!\")","title":"Usage"},{"location":"user_guide/python_interface/#datatypes","text":"Information about Pose , LaserScan data and Twist (velocity) of the robot are passed via the python dataclasses below. @dataclass class Twist: robot_id: str linear: tuple[float, float] angular: float @dataclass class Pose: robot_id: str position: tuple[float, float] orientation: float @dataclass class LaserScan: robot_id: str angle_min: float angle_max: float num_readings: int values: List[float] The source code for xiron_py is hosted here .","title":"Datatypes"}]}